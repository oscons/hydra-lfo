{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/base64-js/index.js",
    "node_modules/buffer/index.js",
    "node_modules/ieee754/index.js",
    "node_modules/pure-uuid/uuid.js",
    "src/components/async.js",
    "src/components/general.js",
    "src/components/generators.js",
    "src/components/maths.js",
    "src/components/modifiers.js",
    "src/components/time.js",
    "src/components/util.js",
    "src/hydralfo.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n",
    "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? Symbol.for('nodejs.util.inspect.custom')\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n",
    "exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n",
    "/*!\n**  Pure-UUID -- Pure JavaScript Based Universally Unique Identifier (UUID)\n**  Copyright (c) 2004-2019 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  Universal Module Definition (UMD)  */\n(function (root, name, factory) {\n    /* global define: false */\n    /* global module: false */\n    if (typeof define === \"function\" && typeof define.amd !== \"undefined\")\n        /*  AMD environment  */\n        define(function () { return factory(root); });\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        /*  CommonJS environment  */\n        module.exports = factory(root);\n        module.exports[\"default\"] = module.exports;\n    }\n    else\n        /*  Browser environment  */\n        root[name] = factory(root);\n}(this, \"UUID\", function (/* root */) {\n\n    /*  array to hex-string conversion  */\n    var a2hs = function (bytes, begin, end, uppercase, str, pos) {\n        var mkNum = function (num, uppercase) {\n            var base16 = num.toString(16);\n            if (base16.length < 2)\n                base16 = \"0\" + base16;\n            if (uppercase)\n                base16 = base16.toUpperCase();\n            return base16;\n        };\n        for (var i = begin; i <= end; i++)\n            str[pos++] = mkNum(bytes[i], uppercase);\n        return str;\n    };\n\n    /*  hex-string to array conversion  */\n    var hs2a = function (str, begin, end, bytes, pos) {\n        for (var i = begin; i <= end; i += 2)\n            bytes[pos++] = parseInt(str.substr(i, 2), 16);\n    };\n\n    /*  This library provides Z85: ZeroMQ's Base-85 encoding/decoding\n        (see http://rfc.zeromq.org/spec:32 for details)  */\n\n    var z85_encoder = (\n        \"0123456789\" +\n         \"abcdefghijklmnopqrstuvwxyz\" +\n         \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n         \".-:+=^!/*?&<>()[]{}@%$#\"\n    ).split(\"\");\n    var z85_decoder = [\n        0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00,\n        0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45,\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n        0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47,\n        0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,\n        0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,\n        0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00,\n        0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n        0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00\n    ];\n    var z85_encode = function (data, size) {\n        if ((size % 4) !== 0)\n            throw new Error(\"z85_encode: invalid input length (multiple of 4 expected)\");\n        var str = \"\", i = 0, value = 0;\n        while (i < size) {\n            value = (value * 256) + data[i++];\n            if ((i % 4) === 0) {\n                var divisor = 85 * 85 * 85 * 85;\n                while (divisor >= 1) {\n                    var idx = Math.floor(value / divisor) % 85;\n                    str += z85_encoder[idx];\n                    divisor /= 85;\n                }\n                value = 0;\n             }\n        }\n        return str;\n    };\n    var z85_decode = function (str, dest) {\n        var l = str.length;\n        if ((l % 5) !== 0)\n            throw new Error(\"z85_decode: invalid input length (multiple of 5 expected)\");\n        if (typeof dest === \"undefined\")\n            dest = new Array(l * 4 / 5);\n        var i = 0, j = 0, value = 0;\n        while (i < l) {\n            var idx = str.charCodeAt(i++) - 32;\n            if (idx < 0 || idx >= z85_decoder.length)\n                break;\n            value = (value * 85) + z85_decoder[idx];\n            if ((i % 5) === 0) {\n                var divisor = 256 * 256 * 256;\n                while (divisor >= 1) {\n                    dest[j++] = Math.trunc((value / divisor) % 256);\n                    divisor /= 256;\n                }\n                value = 0;\n            }\n        }\n        return dest;\n    };\n\n    /*  This library provides conversions between 8/16/32-bit character\n        strings and 8/16/32-bit big/little-endian word arrays.  */\n\n    /*  string to array conversion  */\n    var s2a = function (s, _options) {\n        /*  determine options  */\n        var options = { ibits: 8, obits: 8, obigendian: true };\n        for (var opt in _options)\n            if (typeof options[opt] !== \"undefined\")\n                options[opt] = _options[opt];\n\n        /*  convert string to array  */\n        var a = [];\n        var i = 0;\n        var c, C;\n        var ck = 0;\n        var w;\n        var wk = 0;\n        var sl = s.length;\n        for (;;) {\n            /*  fetch next octet from string  */\n            if (ck === 0)\n                C = s.charCodeAt(i++);\n            c = (C >> (options.ibits - (ck + 8))) & 0xFF;\n            ck = (ck + 8) % options.ibits;\n\n            /*  place next word into array  */\n            if (options.obigendian) {\n                if (wk === 0) w  = (c <<  (options.obits - 8));\n                else          w |= (c << ((options.obits - 8) - wk));\n            }\n            else {\n                if (wk === 0) w  = c;\n                else          w |= (c << wk);\n            }\n            wk = (wk + 8) % options.obits;\n            if (wk === 0) {\n                a.push(w);\n                if (i >= sl)\n                    break;\n            }\n        }\n        return a;\n    };\n\n    /*  array to string conversion  */\n    var a2s = function (a, _options) {\n        /*  determine options  */\n        var options = { ibits: 32, ibigendian: true };\n        for (var opt in _options)\n            if (typeof options[opt] !== \"undefined\")\n                options[opt] = _options[opt];\n\n        /* convert array to string */\n        var s = \"\";\n        var imask = 0xFFFFFFFF;\n        if (options.ibits < 32)\n            imask = (1 << options.ibits) - 1;\n        var al = a.length;\n        for (var i = 0; i < al; i++) {\n            /* fetch next word from array */\n            var w = a[i] & imask;\n\n            /* place next octet into string */\n            for (var j = 0; j < options.ibits; j += 8) {\n                if (options.ibigendian)\n                    s += String.fromCharCode((w >> ((options.ibits - 8) - j)) & 0xFF);\n                else\n                    s += String.fromCharCode((w >> j) & 0xFF);\n            }\n        }\n        return s;\n    };\n\n    /*  this is just a really minimal UI64 functionality,\n        just sufficient enough for the UUID v1 generator and PCG PRNG!  */\n\n    /*  UI64 constants  */\n    var UI64_DIGITS     = 8;    /* number of digits */\n    var UI64_DIGIT_BITS = 8;    /* number of bits in a digit */\n    var UI64_DIGIT_BASE = 256;  /* the numerical base of a digit */\n\n    /*  convert between individual digits and the UI64 representation  */\n    var ui64_d2i = function (d7, d6, d5, d4, d3, d2, d1, d0) {\n        return [ d0, d1, d2, d3, d4, d5, d6, d7 ];\n    };\n\n    /*  the zero represented as an UI64  */\n    var ui64_zero = function () {\n        return ui64_d2i(0, 0, 0, 0, 0, 0, 0, 0);\n    };\n\n    /*  clone the UI64  */\n    var ui64_clone = function (x) {\n        return x.slice(0);\n    };\n\n    /*  convert between number and UI64 representation  */\n    var ui64_n2i = function (n) {\n        var ui64 = ui64_zero();\n        for (var i = 0; i < UI64_DIGITS; i++) {\n            ui64[i] = Math.floor(n % UI64_DIGIT_BASE);\n            n /= UI64_DIGIT_BASE;\n        }\n        return ui64;\n    };\n\n    /*  convert between UI64 representation and number  */\n    var ui64_i2n = function (x) {\n        var n = 0;\n        for (var i = UI64_DIGITS - 1; i >= 0; i--) {\n            n *= UI64_DIGIT_BASE;\n            n += x[i];\n        }\n        return Math.floor(n);\n    };\n\n    /*  add UI64 (y) to UI64 (x) and return overflow/carry as number  */\n    var ui64_add = function (x, y) {\n        var carry = 0;\n        for (var i = 0; i < UI64_DIGITS; i++) {\n            carry += x[i] + y[i];\n            x[i]   = Math.floor(carry % UI64_DIGIT_BASE);\n            carry  = Math.floor(carry / UI64_DIGIT_BASE);\n        }\n        return carry;\n    };\n\n    /*  multiply number (n) to UI64 (x) and return overflow/carry as number  */\n    var ui64_muln = function (x, n) {\n        var carry = 0;\n        for (var i = 0; i < UI64_DIGITS; i++) {\n            carry += x[i] * n;\n            x[i]   = Math.floor(carry % UI64_DIGIT_BASE);\n            carry  = Math.floor(carry / UI64_DIGIT_BASE);\n        }\n        return carry;\n    };\n\n    /*  multiply UI64 (y) to UI64 (x) and return overflow/carry as UI64  */\n    var ui64_mul = function (x, y) {\n        var i, j;\n\n        /*  clear temporary result buffer zx  */\n        var zx = new Array(UI64_DIGITS + UI64_DIGITS);\n        for (i = 0; i < (UI64_DIGITS + UI64_DIGITS); i++)\n            zx[i] = 0;\n\n        /*  perform multiplication operation  */\n        var carry;\n        for (i = 0; i < UI64_DIGITS; i++) {\n            /*  calculate partial product and immediately add to zx  */\n            carry = 0;\n            for (j = 0; j < UI64_DIGITS; j++) {\n                carry += (x[i] * y[j]) + zx[i + j];\n                zx[i + j] = (carry % UI64_DIGIT_BASE);\n                carry /= UI64_DIGIT_BASE;\n            }\n\n            /*  add carry to remaining digits in zx  */\n            for ( ; j < UI64_DIGITS + UI64_DIGITS - i; j++) {\n                carry += zx[i + j];\n                zx[i + j] = (carry % UI64_DIGIT_BASE);\n                carry /= UI64_DIGIT_BASE;\n            }\n        }\n\n        /*  provide result by splitting zx into x and ov  */\n        for (i = 0; i < UI64_DIGITS; i++)\n            x[i] = zx[i];\n        return zx.slice(UI64_DIGITS, UI64_DIGITS);\n    };\n\n    /*  AND operation: UI64 (x) &= UI64 (y)  */\n    var ui64_and = function (x, y) {\n        for (var i = 0; i < UI64_DIGITS; i++)\n            x[i] &= y[i];\n        return x;\n    };\n\n    /*  OR operation: UI64 (x) |= UI64 (y)  */\n    var ui64_or = function (x, y) {\n        for (var i = 0; i < UI64_DIGITS; i++)\n            x[i] |= y[i];\n        return x;\n    };\n\n    /*  rotate right UI64 (x) by a \"s\" bits and return overflow/carry as number  */\n    var ui64_rorn = function (x, s) {\n        var ov = ui64_zero();\n        if ((s % UI64_DIGIT_BITS) !== 0)\n            throw new Error(\"ui64_rorn: only bit rotations supported with a multiple of digit bits\");\n        var k = Math.floor(s / UI64_DIGIT_BITS);\n        for (var i = 0; i < k; i++) {\n            for (var j = UI64_DIGITS - 1 - 1; j >= 0; j--)\n                ov[j + 1] = ov[j];\n            ov[0] = x[0];\n            for (j = 0; j < UI64_DIGITS - 1; j++)\n                x[j] = x[j + 1];\n            x[j] = 0;\n        }\n        return ui64_i2n(ov);\n    };\n\n    /*  rotate right UI64 (x) by a \"s\" bits and return overflow/carry as number  */\n    var ui64_ror = function (x, s) {\n        /*  sanity check shifting  */\n        if (s > (UI64_DIGITS * UI64_DIGIT_BITS))\n            throw new Error(\"ui64_ror: invalid number of bits to shift\");\n\n        /*  prepare temporary buffer zx  */\n        var zx = new Array(UI64_DIGITS + UI64_DIGITS);\n        var i;\n        for (i = 0; i < UI64_DIGITS; i++) {\n            zx[i + UI64_DIGITS] = x[i];\n            zx[i] = 0;\n        }\n\n        /*  shift bits inside zx  */\n        var k1 = Math.floor(s / UI64_DIGIT_BITS);\n        var k2 = s % UI64_DIGIT_BITS;\n        for (i = k1; i < UI64_DIGITS + UI64_DIGITS - 1; i++) {\n            zx[i - k1] =\n                ((zx[i] >>> k2) |\n                 (zx[i + 1] << (UI64_DIGIT_BITS - k2))) &\n                ((1 << UI64_DIGIT_BITS) - 1);\n        }\n        zx[UI64_DIGITS + UI64_DIGITS - 1 - k1] =\n            (zx[UI64_DIGITS + UI64_DIGITS - 1] >>> k2) &\n            ((1 << UI64_DIGIT_BITS) - 1);\n        for (i = UI64_DIGITS + UI64_DIGITS - 1 - k1 + 1; i < UI64_DIGITS + UI64_DIGITS; i++)\n            zx[i] = 0;\n\n        /*  provide result by splitting zx into x and ov  */\n        for (i = 0; i < UI64_DIGITS; i++)\n            x[i] = zx[i + UI64_DIGITS];\n        return zx.slice(0, UI64_DIGITS);\n    };\n\n    /*  rotate left UI64 (x) by a \"s\" bits and return overflow/carry as UI64  */\n    var ui64_rol = function (x, s) {\n        /*  sanity check shifting  */\n        if (s > (UI64_DIGITS * UI64_DIGIT_BITS))\n            throw new Error(\"ui64_rol: invalid number of bits to shift\");\n\n        /*  prepare temporary buffer zx  */\n        var zx = new Array(UI64_DIGITS + UI64_DIGITS);\n        var i;\n        for (i = 0; i < UI64_DIGITS; i++) {\n            zx[i + UI64_DIGITS] = 0;\n            zx[i] = x[i];\n        }\n\n        /*  shift bits inside zx  */\n        var k1 = Math.floor(s / UI64_DIGIT_BITS);\n        var k2 = s % UI64_DIGIT_BITS;\n        for (i = UI64_DIGITS - 1 - k1; i > 0; i--) {\n            zx[i + k1] =\n                ((zx[i] << k2) |\n                 (zx[i - 1] >>> (UI64_DIGIT_BITS - k2))) &\n                ((1 << UI64_DIGIT_BITS) - 1);\n        }\n        zx[0 + k1] = (zx[0] << k2) & ((1 << UI64_DIGIT_BITS) - 1);\n        for (i = 0 + k1 - 1; i >= 0; i--)\n            zx[i] = 0;\n\n        /*  provide result by splitting zx into x and ov  */\n        for (i = 0; i < UI64_DIGITS; i++)\n            x[i] = zx[i];\n        return zx.slice(UI64_DIGITS, UI64_DIGITS);\n    };\n\n    /*  XOR UI64 (y) onto UI64 (x) and return x  */\n    var ui64_xor = function (x, y) {\n        for (var i = 0; i < UI64_DIGITS; i++)\n            x[i] ^= y[i];\n        return;\n    };\n\n    /*  this is just a really minimal UI32 functionality,\n        just sufficient enough for the MD5 and SHA1 digests!  */\n\n    /*  safely add two integers (with wrapping at 2^32)  */\n    var ui32_add = function (x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    };\n\n    /*  bitwise rotate 32-bit number to the left  */\n    var ui32_rol = function (num, cnt) {\n        return (\n              ((num <<        cnt ) & 0xFFFFFFFF)\n            | ((num >>> (32 - cnt)) & 0xFFFFFFFF)\n        );\n    };\n\n    /*  calculate the SHA-1 of an array of big-endian words, and a bit length  */\n    var sha1_core = function (x, len) {\n        /*  perform the appropriate triplet combination function for the current iteration  */\n        function sha1_ft (t, b, c, d) {\n            if (t < 20) return (b & c) | ((~b) & d);\n            if (t < 40) return b ^ c ^ d;\n            if (t < 60) return (b & c) | (b & d) | (c & d);\n            return b ^ c ^ d;\n        }\n\n        /*  determine the appropriate additive constant for the current iteration  */\n        function sha1_kt (t) {\n            return (t < 20) ?  1518500249 :\n                   (t < 40) ?  1859775393 :\n                   (t < 60) ? -1894007588 :\n                               -899497514;\n        }\n\n        /*  append padding  */\n        x[len >> 5] |= 0x80 << (24 - len % 32);\n        x[((len + 64 >> 9) << 4) + 15] = len;\n\n        var w = Array(80);\n        var a =  1732584193;\n        var b =  -271733879;\n        var c = -1732584194;\n        var d =   271733878;\n        var e = -1009589776;\n\n        for (var i = 0; i < x.length; i += 16) {\n            var olda = a;\n            var oldb = b;\n            var oldc = c;\n            var oldd = d;\n            var olde = e;\n            for (var j = 0; j < 80; j++) {\n                if (j < 16)\n                    w[j] = x[i + j];\n                else\n                    w[j] = ui32_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n                var t = ui32_add(\n                    ui32_add(ui32_rol(a, 5), sha1_ft(j, b, c, d)),\n                    ui32_add(ui32_add(e, w[j]), sha1_kt(j))\n                );\n                e = d;\n                d = c;\n                c = ui32_rol(b, 30);\n                b = a;\n                a = t;\n            }\n            a = ui32_add(a, olda);\n            b = ui32_add(b, oldb);\n            c = ui32_add(c, oldc);\n            d = ui32_add(d, oldd);\n            e = ui32_add(e, olde);\n        }\n        return [ a, b, c, d, e ];\n    };\n\n    /*  calculate the SHA-1 of an octet string  */\n    var sha1 = function (s) {\n        return a2s(\n            sha1_core(\n                s2a(s, { ibits: 8, obits: 32, obigendian: true }),\n                s.length * 8),\n            { ibits: 32, ibigendian: true });\n    };\n\n    /*  calculate the MD5 of an array of little-endian words, and a bit length  */\n    var md5_core = function (x, len) {\n        /*  basic operations the algorithm uses  */\n        function md5_cmn (q, a, b, x, s, t) {\n            return ui32_add(ui32_rol(ui32_add(ui32_add(a, q), ui32_add(x, t)), s), b);\n        }\n        function md5_ff (a, b, c, d, x, s, t) {\n            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n        }\n        function md5_gg (a, b, c, d, x, s, t) {\n            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n        }\n        function md5_hh (a, b, c, d, x, s, t) {\n            return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n        }\n        function md5_ii (a, b, c, d, x, s, t) {\n            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n        }\n\n        /*  append padding  */\n        x[len >> 5] |= 0x80 << ((len) % 32);\n        x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n        var a =  1732584193;\n        var b =  -271733879;\n        var c = -1732584194;\n        var d =   271733878;\n\n        for (var i = 0; i < x.length; i += 16) {\n            var olda = a;\n            var oldb = b;\n            var oldc = c;\n            var oldd = d;\n\n            a = md5_ff(a, b, c, d, x[i+ 0],  7,  -680876936);\n            d = md5_ff(d, a, b, c, x[i+ 1], 12,  -389564586);\n            c = md5_ff(c, d, a, b, x[i+ 2], 17,   606105819);\n            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n            a = md5_ff(a, b, c, d, x[i+ 4],  7,  -176418897);\n            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n            b = md5_ff(b, c, d, a, x[i+ 7], 22,   -45705983);\n            a = md5_ff(a, b, c, d, x[i+ 8],  7,  1770035416);\n            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n            c = md5_ff(c, d, a, b, x[i+10], 17,      -42063);\n            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n            a = md5_ff(a, b, c, d, x[i+12],  7,  1804603682);\n            d = md5_ff(d, a, b, c, x[i+13], 12,   -40341101);\n            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n            a = md5_gg(a, b, c, d, x[i+ 1],  5,  -165796510);\n            d = md5_gg(d, a, b, c, x[i+ 6],  9, -1069501632);\n            c = md5_gg(c, d, a, b, x[i+11], 14,   643717713);\n            b = md5_gg(b, c, d, a, x[i+ 0], 20,  -373897302);\n            a = md5_gg(a, b, c, d, x[i+ 5],  5,  -701558691);\n            d = md5_gg(d, a, b, c, x[i+10],  9,    38016083);\n            c = md5_gg(c, d, a, b, x[i+15], 14,  -660478335);\n            b = md5_gg(b, c, d, a, x[i+ 4], 20,  -405537848);\n            a = md5_gg(a, b, c, d, x[i+ 9],  5,   568446438);\n            d = md5_gg(d, a, b, c, x[i+14],  9, -1019803690);\n            c = md5_gg(c, d, a, b, x[i+ 3], 14,  -187363961);\n            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n            a = md5_gg(a, b, c, d, x[i+13],  5, -1444681467);\n            d = md5_gg(d, a, b, c, x[i+ 2],  9,   -51403784);\n            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n            a = md5_hh(a, b, c, d, x[i+ 5],  4,     -378558);\n            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n            b = md5_hh(b, c, d, a, x[i+14], 23,   -35309556);\n            a = md5_hh(a, b, c, d, x[i+ 1],  4, -1530992060);\n            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n            c = md5_hh(c, d, a, b, x[i+ 7], 16,  -155497632);\n            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n            a = md5_hh(a, b, c, d, x[i+13],  4,   681279174);\n            d = md5_hh(d, a, b, c, x[i+ 0], 11,  -358537222);\n            c = md5_hh(c, d, a, b, x[i+ 3], 16,  -722521979);\n            b = md5_hh(b, c, d, a, x[i+ 6], 23,    76029189);\n            a = md5_hh(a, b, c, d, x[i+ 9],  4,  -640364487);\n            d = md5_hh(d, a, b, c, x[i+12], 11,  -421815835);\n            c = md5_hh(c, d, a, b, x[i+15], 16,   530742520);\n            b = md5_hh(b, c, d, a, x[i+ 2], 23,  -995338651);\n\n            a = md5_ii(a, b, c, d, x[i+ 0],  6,  -198630844);\n            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n            b = md5_ii(b, c, d, a, x[i+ 5], 21,   -57434055);\n            a = md5_ii(a, b, c, d, x[i+12],  6,  1700485571);\n            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n            c = md5_ii(c, d, a, b, x[i+10], 15,    -1051523);\n            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n            a = md5_ii(a, b, c, d, x[i+ 8],  6,  1873313359);\n            d = md5_ii(d, a, b, c, x[i+15], 10,   -30611744);\n            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n            a = md5_ii(a, b, c, d, x[i+ 4],  6,  -145523070);\n            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n            c = md5_ii(c, d, a, b, x[i+ 2], 15,   718787259);\n            b = md5_ii(b, c, d, a, x[i+ 9], 21,  -343485551);\n\n            a = ui32_add(a, olda);\n            b = ui32_add(b, oldb);\n            c = ui32_add(c, oldc);\n            d = ui32_add(d, oldd);\n        }\n        return [ a, b, c, d ];\n    };\n\n    /*  calculate the MD5 of an octet string  */\n    var md5 = function (s) {\n        return a2s(\n            md5_core(\n                s2a(s, { ibits: 8, obits: 32, obigendian: false }),\n                s.length * 8),\n            { ibits: 32, ibigendian: false });\n    };\n\n    /*  PCG Pseudo-Random-Number-Generator (PRNG)\n        http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf\n        This is the PCG-XSH-RR variant (\"xorshift high (bits), random rotation\"),\n        based on 32-bit output, 64-bit internal state and the formulas:\n        state = state * MUL + INC\n        output = rotate32((state ^ (state >> 18)) >> 27, state >> 59)  */\n\n    var PCG = function (seed) {\n        /*  pre-load some \"magic\" constants  */\n        this.mul   = ui64_d2i(0x58, 0x51, 0xf4, 0x2d, 0x4c, 0x95, 0x7f, 0x2d);\n        this.inc   = ui64_d2i(0x14, 0x05, 0x7b, 0x7e, 0xf7, 0x67, 0x81, 0x4f);\n        this.mask  = ui64_d2i(0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff);\n\n        /*  generate an initial internal state  */\n        this.state = ui64_clone(this.inc);\n        this.next();\n        ui64_and(this.state, this.mask);\n        seed = ui64_n2i(seed !== undefined ?\n            (seed >>> 0) : ((Math.random() * 0xffffffff) >>> 0));\n        ui64_or(this.state, seed);\n        this.next();\n    };\n    PCG.prototype.next = function () {\n        /*  save current state  */\n        var state = ui64_clone(this.state);\n\n        /*  advance internal state  */\n        ui64_mul(this.state, this.mul);\n        ui64_add(this.state, this.inc);\n\n        /*  calculate: (state ^ (state >> 18)) >> 27  */\n        var output = ui64_clone(state);\n        ui64_ror(output, 18);\n        ui64_xor(output, state);\n        ui64_ror(output, 27);\n\n        /*  calculate: state >> 59  */\n        var rot = ui64_clone(state);\n        ui64_ror(rot, 59);\n\n\t\t/*  calculate: rotate32(xorshifted, rot)  */\n        ui64_and(output, this.mask);\n        var k = ui64_i2n(rot);\n        var output2 = ui64_clone(output);\n        ui64_rol(output2, 32 - k);\n        ui64_ror(output, k);\n        ui64_xor(output, output2);\n\n        /*  return pseudo-random number  */\n        return ui64_i2n(output);\n    };\n    var pcg = new PCG();\n\n    /*  utility function: simple Pseudo Random Number Generator (PRNG)  */\n    var prng = function (len, radix) {\n        var bytes = [];\n        for (var i = 0; i < len; i++)\n            bytes[i] = (pcg.next() % radix);\n        return bytes;\n    };\n\n    /*  internal state  */\n    var time_last = 0;\n    var time_seq  = 0;\n\n    /*  the API constructor  */\n    var UUID = function () {\n        if (arguments.length === 1 && typeof arguments[0] === \"string\")\n            this.parse.apply(this, arguments);\n        else if (arguments.length >= 1 && typeof arguments[0] === \"number\")\n            this.make.apply(this, arguments);\n        else if (arguments.length >= 1)\n            throw new Error(\"UUID: constructor: invalid arguments\");\n        else\n            for (var i = 0; i < 16; i++)\n                this[i] = 0x00;\n    };\n\n    /*  inherit from a standard class which provides the\n        best UUID representation in the particular environment  */\n    /* global Uint8Array: false */\n    /* global Buffer: false */\n    if (typeof Uint8Array !== \"undefined\")\n        /*  HTML5 TypedArray (browser environments: IE10, FF, CH, SF, OP)\n            (http://caniuse.com/#feat=typedarrays)  */\n        UUID.prototype = new Uint8Array(16);\n    else if (Buffer)\n        /*  Node Buffer (server environments: Node.js, IO.js)  */\n        UUID.prototype = new Buffer(16);\n    else\n        /*  JavaScript (any environment)  */\n        UUID.prototype = new Array(16);\n    UUID.prototype.constructor = UUID;\n\n    /*  API method: generate a particular UUID  */\n    UUID.prototype.make = function (version) {\n        var i;\n        var uuid = this;\n        if (version === 1) {\n            /*  generate UUID version 1 (time and node based)  */\n\n            /*  determine current time and time sequence counter  */\n            var date = new Date();\n            var time_now = date.getTime();\n            if (time_now !== time_last)\n                time_seq = 0;\n            else\n                time_seq++;\n            time_last = time_now;\n\n            /*  convert time to 100*nsec  */\n            var t = ui64_n2i(time_now);\n            ui64_muln(t, 1000 * 10);\n\n            /*  adjust for offset between UUID and Unix Epoch time  */\n            ui64_add(t, ui64_d2i(0x01, 0xB2, 0x1D, 0xD2, 0x13, 0x81, 0x40, 0x00));\n\n            /*  compensate for low resolution system clock by adding\n                the time/tick sequence counter  */\n            if (time_seq > 0)\n                ui64_add(t, ui64_n2i(time_seq));\n\n            /*  store the 60 LSB of the time in the UUID  */\n            var ov;\n            ov = ui64_rorn(t, 8); uuid[3] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[2] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[1] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[0] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[5] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[4] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[7] = (ov & 0xFF);\n            ov = ui64_rorn(t, 8); uuid[6] = (ov & 0x0F);\n\n            /*  generate a random clock sequence  */\n            var clock = prng(2, 255);\n            uuid[8] = clock[0];\n            uuid[9] = clock[1];\n\n            /*  generate a random local multicast node address  */\n            var node = prng(6, 255);\n            node[0] |= 0x01;\n            node[0] |= 0x02;\n            for (i = 0; i < 6; i++)\n                uuid[10 + i] = node[i];\n        }\n        else if (version === 4) {\n            /*  generate UUID version 4 (random data based)  */\n            var data = prng(16, 255);\n            for (i = 0; i < 16; i++)\n                 this[i] = data[i];\n        }\n        else if (version === 3 || version === 5) {\n            /*  generate UUID version 3/5 (MD5/SHA-1 based)  */\n            var input = \"\";\n            var nsUUID = (\n                typeof arguments[1] === \"object\" && arguments[1] instanceof UUID ?\n                arguments[1] : new UUID().parse(arguments[1])\n            );\n            for (i = 0; i < 16; i++)\n                 input += String.fromCharCode(nsUUID[i]);\n            input += arguments[2];\n            var s = version === 3 ? md5(input) : sha1(input);\n            for (i = 0; i < 16; i++)\n                 uuid[i] = s.charCodeAt(i);\n        }\n        else\n            throw new Error(\"UUID: make: invalid version\");\n\n        /*  brand with particular UUID version  */\n        uuid[6] &= 0x0F;\n        uuid[6] |= (version << 4);\n\n        /*  brand as UUID variant 2 (DCE 1.1)  */\n        uuid[8] &= 0x3F;\n        uuid[8] |= (0x02 << 6);\n\n        return uuid;\n    };\n\n    /*  API method: format UUID into usual textual representation  */\n    UUID.prototype.format = function (type) {\n        var str, arr;\n        if (type === \"z85\")\n            str = z85_encode(this, 16);\n        else if (type === \"b16\") {\n            arr = Array(32);\n            a2hs(this, 0, 15, true, arr, 0);\n            str = arr.join(\"\");\n        }\n        else if (type === undefined || type === \"std\") {\n            arr = new Array(36);\n            a2hs(this,  0,  3, false, arr,  0); arr[ 8] = \"-\";\n            a2hs(this,  4,  5, false, arr,  9); arr[13] = \"-\";\n            a2hs(this,  6,  7, false, arr, 14); arr[18] = \"-\";\n            a2hs(this,  8,  9, false, arr, 19); arr[23] = \"-\";\n            a2hs(this, 10, 15, false, arr, 24);\n            str = arr.join(\"\");\n        }\n        return str;\n    };\n\n    /*  API method: format UUID into usual textual representation  */\n    UUID.prototype.toString = function (type) {\n        return this.format(type);\n    };\n\n    /*  API method: parse UUID from usual textual representation  */\n    UUID.prototype.parse = function (str, type) {\n        if (typeof str !== \"string\")\n            throw new Error(\"UUID: parse: invalid argument (type string expected)\");\n        if (type === \"z85\")\n            z85_decode(str, this);\n        else if (type === \"b16\")\n            hs2a(str, 0, 35, this, 0);\n        else if (type === undefined || type === \"std\") {\n            var map = {\n                \"nil\":     \"00000000-0000-0000-0000-000000000000\",\n                \"ns:DNS\":  \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n                \"ns:URL\":  \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\",\n                \"ns:OID\":  \"6ba7b812-9dad-11d1-80b4-00c04fd430c8\",\n                \"ns:X500\": \"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"\n            };\n            if (map[str] !== undefined)\n                str = map[str];\n            else if (!str.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/))\n                throw new Error(\"UUID: parse: invalid string representation \" +\n                    \"(expected \\\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\\")\");\n            hs2a(str,  0,  7, this,  0);\n            hs2a(str,  9, 12, this,  4);\n            hs2a(str, 14, 17, this,  6);\n            hs2a(str, 19, 22, this,  8);\n            hs2a(str, 24, 35, this, 10);\n        }\n        return this;\n    };\n\n    /*  API method: export UUID into standard array of numbers  */\n    UUID.prototype.export = function () {\n        var arr = Array(16);\n        for (var i = 0; i < 16; i++)\n            arr[i] = this[i];\n        return arr;\n    };\n\n    /*  API method: import UUID from standard array of numbers  */\n    UUID.prototype.import = function (arr) {\n        if (!(typeof arr === \"object\" && arr instanceof Array))\n            throw new Error(\"UUID: import: invalid argument (type Array expected)\");\n        if (arr.length !== 16)\n            throw new Error(\"UUID: import: invalid argument (Array of length 16 expected)\");\n        for (var i = 0; i < 16; i++) {\n            if (typeof arr[i] !== \"number\")\n                throw new Error(\"UUID: import: invalid array element #\" + i +\n                    \" (type Number expected)\");\n            if (!(isFinite(arr[i]) && Math.floor(arr[i]) === arr[i]))\n                throw new Error(\"UUID: import: invalid array element #\" + i +\n                    \" (Number with integer value expected)\");\n            if (!(arr[i] >= 0 && arr[i] <= 255))\n                throw new Error(\"UUID: import: invalid array element #\" + i +\n                    \" (Number with integer value in range 0...255 expected)\");\n            this[i] = arr[i];\n        }\n        return this;\n    };\n\n    /*  API method: compare UUID against another one  */\n    UUID.prototype.compare = function (other) {\n        if (typeof other !== \"object\")\n            throw new Error(\"UUID: compare: invalid argument (type UUID expected)\");\n        if (!(other instanceof UUID))\n            throw new Error(\"UUID: compare: invalid argument (type UUID expected)\");\n        for (var i = 0; i < 16; i++) {\n            if (this[i] < other[i])\n                return -1;\n            else if (this[i] > other[i])\n                return +1;\n        }\n        return 0;\n    };\n\n    /*  API method: hash UUID by XOR-folding it k times  */\n    UUID.prototype.fold = function (k) {\n        if (typeof k === \"undefined\")\n            throw new Error(\"UUID: fold: invalid argument (number of fold operations expected)\");\n        if (k < 1 || k > 4)\n            throw new Error(\"UUID: fold: invalid argument (1-4 fold operations expected)\");\n        var n = 16 / Math.pow(2, k);\n        var hash = new Array(n);\n        for (var i = 0; i < n; i++) {\n            var h = 0;\n            for (var j = 0; i + j < 16; j += n)\n                h ^= this[i + j];\n            hash[i] = h;\n        }\n        return hash;\n    };\n\n    UUID.PCG = PCG;\n\n    /*  export API  */\n    return UUID;\n}));\n\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, expand_args, get_bpm, get_global_env, uuid} from \"./util\";\n\nconst _functions = {};\n\n_functions.async = {\n    doc: {\n        title: \"Asynchronously execute a function\"\n        , command: [\n            'async(f, r, d)'\n            , 'async({f, r, d})'\n        ]\n        , params: {\n            f: \"Function to execute. Default is `() => {}`\"\n            , r: `Run frequency of the function. A value of \\`0\\` or less will\nresult in the function being called only once. Default is \\`1\\``\n            , d: \"Delay before first run. Default is `0`\"\n        }\n        , return: \"The unaltered input value.\"\n        , description: `The provided function is run with a frequency of \\`r\\`\nper time unit. All parameters are based on the current \\`time\\` and \\`bpm\\`,\nassuming \\`time\\` is in beats. Timing is not guaranteed, so \\`f\\` might drift\nover time.\n\nInternally async is implemented using setTimeout with all implications regarding\nexecution context.`\n        , examples: [`const x = {v: 3};\nshape(\n    L.async(() => x.v = ((x.v + 1 ) % 5) + 3)\n        .set(() => x.v)\n).out(o0);`\n        ]\n    }\n    , fun: (args) => {\n        const {f: fn, r: run_freq, d: delay} = expand_args({f: ud, r: 1, d: 0}, args);\n\n        const thread_state = {\n            id: uuid()\n            , do_stop: false\n            , running: false\n            , last_args: [ud, ud, ud]\n        };\n\n        return (input, gen_args, run_args) => {\n            thread_state.last_args = [input, gen_args, run_args];\n\n            if (typeof fn === 'undefined') {\n                return input;\n            }\n\n            // luckyily javascript is single threaded...\n            let asyncs = gen_args.global_state.async;\n            if (typeof asyncs !== 'undefined') {\n                return input;\n            }\n\n            gen_args.global_state.async = {};\n            asyncs = gen_args.global_state.async;\n\n            if (typeof asyncs[thread_state.id] !== 'undefined') {\n                return input;\n            }\n\n            gen_args.global_state.cleanup.push(() => {\n                thread_state.do_stop = true;\n                thread_state.last_args = [ud, ud, ud];\n            });\n\n            asyncs[thread_state.id] = {\n                init: gen_args.values.time\n                , state: thread_state\n            };\n\n            const bpm = get_bpm(gen_args, run_args, false);\n            const beats_to_millis = (n) => Math.max((60 / bpm) / n * 1000, 100);\n            const timeout = run_freq <= 0 ? -1 : beats_to_millis(run_freq);\n            const delayt = beats_to_millis(delay);\n            const env = get_global_env();\n            const tfunc = () => {\n                if (thread_state.do_stop) {\n                    return;\n                }\n                const ret = fn(...thread_state.last_args);\n                if (!ret) {\n                    return;\n                }\n                if (timeout > 0) {\n                    env.setTimeout(tfunc, timeout);\n                }\n            };\n\n            console.log(`startring thread ${thread_state.id}, delayt=${delayt} timeout=${timeout}`);\n            if (typeof env !== 'undefined') {\n                if (delay <= 0) {\n                    thread_state.running = true;\n                    tfunc();\n                } else {\n                    env.setTimeout(() => {\n                        thread_state.running = true;\n                        tfunc();\n                    }, delayt);\n                }\n            }\n            \n            return input;\n        };\n    }\n};\n\nexport const functions = {\n    __category: \"async\"\n    , __doc: {\n        title: \"Asynchronous functions\"\n        , description: `Functions allowing you to perform actions asynchronously\nto the main processing done in Hydra.`\n    }\n    , ..._functions\n};\n\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, expand_args, freeze_values} from \"./util\";\n\nconst _functions = {};\n\n_functions.set =\n    {doc: {\n        title: \"Set a value\"\n        , command: [\n            'set(v, t)', 'set({v, t})'\n        ]\n        , params: {\n            v: `The value to set. This can either be a scalar value or a\nfunction that returns a scalar value.`\n        }\n        , return: \"The set value\"\n        , description: `Set the `\n        , see_also: ['use', 'time']\n        , examples: [\n            'Shape(L.set(5))'\n            , 'Shape(L.set(({time}) => time % 5))'\n            , 'Shape(L.set(({time}) => time + 5).)'\n        ]\n    }\n    , fun: (args) => {\n        let avalue = 0;\n        let tgt_value = ud;\n        \n        if (typeof args !== 'undefined') {\n            if (Array.isArray(args)) {\n                if (args.length > 0) {\n                    const [first_arg, second_arg] = args;\n                    if (typeof first_arg === 'object') {\n                        if (Array.isArray(first_arg)) {\n                            avalue = 0;\n                        } else if ('v' in first_arg) {\n                            avalue = first_arg.v;\n                        } else {\n                            avalue = 0;\n                        }\n                    } else {\n                        avalue = first_arg;\n                    }\n                    if (typeof second_arg === 'string') {\n                        tgt_value = second_arg;\n                    }\n                }\n            } else if (typeof args !== 'object') {\n                avalue = args;\n            }\n        }\n\n        if (typeof args !== 'undefined' && args.length > 0\n            && (typeof args[0] !== 'object'\n                || Array.isArray(args[0])\n                || 'v' in Object.keys(args[0])\n            )) {\n            const {v} = expand_args({v: ud}, args);\n            avalue = v;\n        }\n        const value = avalue;\n\n        return (input, gen_args, run_args) => {\n            const vv = freeze_values(value, run_args, gen_args);\n            \n            if (typeof tgt_value !== 'undefined') {\n                gen_args.values[tgt_value] = vv;\n\n                if (tgt_value !== gen_args.current_value) {\n                    return input;\n                }\n            }\n\n            return vv;\n        };\n    }};\n\n_functions.use =\n    {doc: {\n        title: \"Set the currently modified value.\"\n        , command: [\n            \"use(n, c)\", \"use({n, c})\"\n        ]\n        , params: {\n            n: `The name of the value. The default value is \\`val\\`. You can\nmanipulate \\`time\\` or \\`bpm\\` or any other string value as well.`\n            , c: `Should the currently in use value be copied over to the new on\none. Either \\`true\\` to copy or \\`false\\` to keep the value untouched. Defaul\nis \\`false\\``\n        }\n        , return: \"The currently in use value.\"\n        , description: `You can manipulate a custom list of values which\nyou can refer to by name. The \\`val\\` value is the default used initially.\nThe last value that's in \\`use\\` will be what the LFO function finally returns.\n\nThough \\`fast\\` and\nthe likes are the preferred way to manipulate time you can also use\n\\`use('time')\\` to manipulate time directly or return its value from the LFO \nfunction.`\n        , examples: [\n            \"shape(L.set(10).use('time').mul(2).use('val')).out(o0)\"\n            , \"shape(10, L.use('time').add(1).use('val').sin().add(1)).out(o0)\"\n        ]\n    }\n    , fun: (args) => {\n        const {n: name, c: copy} = expand_args({n: \"val\", c: false}, args);\n\n        return (input, gen_args, run_args) => {\n            const [nv, cv] = freeze_values([name, copy], run_args, gen_args);\n\n            let ret = gen_args.values[nv];\n            \n            if (cv) {\n                ret = input;\n            }\n            gen_args.current_value = nv;\n\n            return ret;\n        };\n    }};\n\n_functions.get =\n    {doc: {\n        title: \"Set the current value to a named one.\"\n        , command: [\n            \"get(n)\", \"get({n})\"\n        ]\n        , params: {\n            n: \"The name of the value to get, e.g. `time` to get the current time. Default value is `val`\"\n        }\n        , return: \"The value saved unter the name specified by `n`. Can be undefined.\"\n        , description: ``\n        , examples: [\n            \"shape(3, L.get('time').mul(2).use('time', true).sin(1, 0.5, 0.5)).out(o0)\"\n        ]\n    }\n    , un: (args) => {\n        const {n: name} = expand_args({n: \"val\"}, args);\n\n        return (input, gen_args, run_args) => {\n            const [nv] = freeze_values([name], run_args, gen_args);\n\n            const ret = gen_args.values[nv];\n            \n            gen_args.current_value = ret;\n\n            return ret;\n        };\n    }};\n\n_functions.used =\n    {doc: {\n        title: \"Return the name of the currently in `use` value\"\n        , command: [\n            \"used()\"\n        ]\n        , params: {\n        }\n        , return: \"The name set by the last `use` command or `val` if not set at all.\"\n        , description: `This function allows you to retrieve the name of the\ncurrent default parameter that is modufied by functions like \\`mul\\` or \\`set\\`.\n\nThis is usually most helpful for debugging purposes, though you could use it in\n\\`map\\` too.`\n        , examples: [\n            \"console.log(L.used()) // == 'val'\"\n            , \"console.log(L.use('time').used()) == 'time'\"\n            , `\nshape(3)\n    .rotate(\n        L.use(() => time % 2 < 1 ? \"cos\" : \"sin\"))\n            .used()\n            .map((x, {time}) => eval(\\`Math.$\\{x}(time)\\`))\n            .mul(2)\n    ).out(o0)\n`\n        ]\n    }\n    , fun: () => ((_, gen_args) => gen_args.current_value)};\n\n_functions.noop =\n    {doc: {\n        title: \"Do nothing\"\n        , command: [\"noop()\"]\n        , params: {\n        }\n        , return: \"The unmodified input value.\"\n        , description: `This function performs no operation. It's mostly used\nfor debugging and testing purposes`\n        , examples: [\n            \"L.noop().gen()({val: 2}) // == 2\"\n            , \"L.time().noop().run({time: 2}) // == 2\"\n        ]\n    }\n    , fun: () => ((input) => input)};\n\nexport const functions = {\n    __category: \"general\"\n    , __doc: {\n        title: \"General Hydra LFO utility functions\"\n        , description: `Functions that perform various tasks on Hydra LFO\nvalues or its processing chain.`\n    }\n    , ..._functions\n};\n\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, undefault, expand_args, freeze_values, mix_values, get_time, get_bpm} from \"./util\";\n\nconst _functions = {};\n\nconst TAU = 2 * Math.PI;\n\n// TODO: use LUTs\n_functions.sin = {fun: (args) => {\n    const {f: frequency, s: scale, o: offset} = expand_args({f: 1, s: 1, o: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [fv, sv, ov] = freeze_values([frequency, scale, offset], run_args, gen_args);\n        let time = 0;\n\n        time = undefault(input, get_time(gen_args, run_args, true));\n        time = undefault(time, 0.25);\n\n        return (((Math.sin(time * TAU * fv) / 2) + 0.5) * sv) + ov;\n    };\n}};\n\n_functions.rnd = {fun: (args) => {\n    const {s: scale, o: offset, m: mix} = expand_args({s: ud, o: 0, m: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [sv, ov, mv] = freeze_values([scale, offset, mix], run_args, gen_args);\n\n        let svx = 1;\n        if (typeof input === 'undefined') {\n            if (typeof sv === 'undefined') {\n                svx = 1;\n            } else {\n                svx = sv;\n            }\n        } else if (typeof sv === 'undefined') {\n            svx = input;\n        } else {\n            svx = mix_values(sv, input, mv);\n        }\n\n        return (Math.random() * svx) + ov;\n    };\n}};\n\n_functions.rand = _functions.rnd;\n\n_functions.range = {fun: (args) => {\n    const {u: upper, l: lower, s: step} = expand_args({u: 1, l: 0, s: 0.1}, args);\n\n    return (input, gen_args, run_args) => {\n        const [uv, lv, sv] = freeze_values([upper, lower, step], run_args, gen_args);\n        \n        let idx = undefault(input, get_time(gen_args, run_args, true));\n        \n        idx = undefault(idx, 0);\n\n        let ub = uv;\n        let lb = lv;\n\n        // console.log({t: run_args[0].time, input, idx, ub, lb, sv});\n        if (ub < lb) {\n            const tmp = lb;\n            lb = ub;\n            ub = tmp;\n        } else if (ub === lb) {\n            return ub;\n        } else if (sv === 0 || idx === 0) {\n            return lb;\n        }\n\n        const range = ub - lb;\n        let v = (sv * idx) + lb;\n        // console.log({v, sv, idx, lb, range});\n\n        // TODO: test if this can be replaced by \"mod\" (likely can)\n        while (v < lb) {\n            v = v + range;\n        }\n        while (v >= ub) {\n            v = v - range;\n        }\n        // console.log({v});\n        return v;\n    };\n}};\n\n_functions.choose = {fun: (args) => {\n    const {v: values, s: scale} = expand_args({v: [0, 1], s: 1}, args);\n\n    return (input, gen_args, run_args) => {\n        const [vv, sv] = freeze_values([values, scale], run_args, gen_args);\n\n        if (vv.length === 0) {\n            return 0;\n        }\n        \n        let idx = undefault(input, get_time(gen_args, run_args, true));\n\n        idx = undefault(idx, 0) * sv;\n\n        idx = Math.floor(Math.abs(idx));\n        idx = idx % vv.length;\n\n        let val = vv[idx];\n\n        const fmark = `choose_mark_${new Date().getTime()}`;\n        let maxcnt = 10;\n\n        while (typeof val === 'function') {\n            const fn = val;\n            fn.__choose_mark = fmark;\n\n            val = fn(...run_args, gen_args);\n            if (maxcnt-- <= 0 || (typeof val === 'function' && val.__choose_mark === fmark)) {\n                // loop detected\n                val = 0;\n                break;\n            }\n\n            delete fn.__choose_mark;\n        }\n        return val;\n    };\n}};\n\n\nexport const functions = {\n    __category: \"generator\"\n    , __doc: {\n        title: \"Generator functions\"\n        , description: `Functions that generate values and can be used as the\nthe source for other functions and parameters.`\n    }\n    , ..._functions\n};\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, undefault, expand_args, freeze_values, mix_values, get_time, get_bpm} from \"./util\";\n\nexport const TAU = 2 * Math.PI;\n\nconst _functions = {};\n\n_functions.add = {doc: ({doc_link}) => ({\n    title: \"Add a value\"\n    , command: [\"add(v)\", \"add({v})\"]\n    , params: {\n        v: \"The value to add. Default is 0\"\n    }\n    , return: \"The previous value plus the added value `v`.\"\n    , description: `Add a value to the current value, depending on ${doc_link('use', \"`use`\")}`\n    , examples: [\n        \"shape(L.time().mod(3).add(2).floor()).out(o0)\"\n        , \"shape(3,L.time().mod(3).div(6).add(L.sin({f:1/2,s:0.2,o:0.1}))).out(o0)\"\n    ]\n})\n, fun: (args) => {\n    const {v: value} = expand_args({v: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const vv = freeze_values(value, run_args, gen_args);\n        return undefault(input, 0) + vv;\n    };\n}};\n\n_functions.sub = {doc: ({doc_link}) => ({\n    title: \"Subtract a value\"\n    , command: [\"sub(v)\", \"sub({v})\"]\n    , params: {\n        v: \"The value to subtract. Default is 0\"\n    }\n    , return: \"The previous value minus the subtracted value `v`.\"\n    , description: `Subtract a value from the current value, depending on ${doc_link('use', \"`use`\")}`\n    , examples: [\n        \"shape(3).scrollY(-0.2).rotate(L.time().mod(10).sub(5).floor().rad(1/10)).out(o0)\"\n    ]\n})\n, fun: (args) => {\n    const {v: value} = expand_args({v: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const vv = freeze_values(value, run_args, gen_args);\n        return undefault(input, 0) - vv;\n    };\n}};\n\n_functions.floor = {doc: ({doc_link}) => ({\n    title: \"Roud down to the nearest number of digits\"\n    , command: [\"floor(d)\", \"floor({d})\"]\n    , params: {\n        d: `The number of digits after the decimal point to round down to.\nDefault is 0 which is effectively the nearest lower integer.`\n    }\n    , return: \"Rounded value\"\n    , description: `Rounds the current value down to the specified number of decimal places. This can\nbe used to discretize continous valued functions.`\n    , examples: [\n        \"shape(3).scrollY(L.range({u:10,s:0.5}).floor(1)).out(o0)\"\n    ]\n})\n, fun: (args) => {\n    const {d: digits} = expand_args({d: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const dv = freeze_values(digits, run_args, gen_args);\n        const fact = Math.pow(10, dv);\n\n        return Math.floor(undefault(input, 0) * fact) / fact;\n    };\n}};\n\n_functions.mul = {fun: (args) => {\n    const {v: value} = expand_args({v: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const vv = freeze_values(value, run_args, gen_args);\n        return input * vv;\n    };\n}};\n\n_functions.div = {fun: (args) => {\n    const {v: value} = expand_args({v: 1}, args);\n\n    return (input, gen_args, run_args) => {\n        const vv = freeze_values(value, run_args, gen_args);\n\n        const definput = undefault(input, 0);\n        \n        if (vv === 0) {\n            return definput / 0.0000000000001;\n        }\n        return definput / vv;\n    };\n}};\n\n_functions.mod = {fun: (args) => {\n    const {v: value} = expand_args({v: 1}, args);\n\n    return (input, gen_args, run_args) => {\n        const vv = freeze_values(value, run_args, gen_args);\n        \n        if (vv === 0) {\n            return 0;\n        }\n        return undefault(input, 0) % vv;\n    };\n}};\n\n_functions.rad = {fun: (args) => {\n    const {s: scale, o: offset} = expand_args({s: 1, o: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [sv, ov] = freeze_values([scale, offset], run_args, gen_args);\n        \n        const rv = undefault(input, 0);\n        \n        return (rv + ov) * sv * TAU;\n    };\n\n}};\n\n\nexport const functions = {\n    __category: \"maths\"\n    , __doc: {\n        title: \"Math related functions\"\n        , description: `Various generally maths related functions that act on\nHydra LFO values.`\n    }\n    , ..._functions\n};\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, undefault, expand_args, freeze_values, mix_values, get_time, get_bpm} from \"./util\";\n\nconst _functions = {};\n\n// TODO: this should be locked to time/BPM boundaries\n_functions.sah = {fun: (args) => {\n    const {h: hold_time} = expand_args({h: 1}, args);\n\n    return (input, gen_args, run_args) => {\n        const hv = freeze_values(hold_time, run_args, gen_args);\n\n        let prev_time = Number.MIN_SAFE_INTEGER;\n        if (typeof gen_args.private_state.time !== 'undefined') {\n            prev_time = gen_args.private_state.time;\n        }\n        if (typeof gen_args.private_state.value === 'undefined') {\n            gen_args.private_state.value = input;\n        }\n\n        if ((gen_args.values.time - prev_time) >= Math.abs(hv)) {\n            gen_args.private_state.value = input;\n            gen_args.private_state.time = gen_args.values.time;\n        }\n        \n        return gen_args.private_state.value;\n    };\n}};\n\nconst DEFAULT_SLEW_TYPE = 'h';\nconst SLEW_TYPES = {\n    h: (x, over) => x - over\n};\n\n_functions.slew = {fun: (args) => {\n    const {r: rate, t: type, i: ival} = expand_args({r: 0.5, t: DEFAULT_SLEW_TYPE, i: 1}, args);\n\n    return (input, gen_args, run_args) => {\n        const [rv, iv] = freeze_values([rate, ival], run_args, gen_args);\n\n        if (typeof gen_args.private_state.time === 'undefined') {\n            gen_args.private_state.time = get_time(gen_args, run_args);\n            gen_args.private_state.prev = input;\n            gen_args.private_state.tgt = input;\n            return input;\n        }\n\n        const tgt = undefault(input, gen_args.private_state.tgt);\n        if (typeof tgt === 'undefined') {\n            return ud;\n        }\n\n        if (typeof gen_args.private_state.prev === 'undefined') {\n            gen_args.private_state.prev = tgt;\n        }\n\n        const time = get_time(gen_args, run_args);\n\n        const tdiff = time - gen_args.private_state.time;\n        const vdiff = tgt - gen_args.private_state.prev;\n\n        gen_args.private_state.time = time;\n        gen_args.private_state.tgt = tgt;\n\n        const over = vdiff - ((tdiff / iv) * rv);\n\n        let nv = tgt;\n        if (over > 0) {\n            let tv = freeze_values(type, run_args, gen_args);\n\n            if (typeof tv !== 'string') {\n                tv = DEFAULT_SLEW_TYPE;\n            }\n            tv = SLEW_TYPES[tv];\n            if (typeof tv === 'undefined') {\n                tv = SLEW_TYPES[DEFAULT_SLEW_TYPE];\n            }\n            nv = tv(nv, over);\n        }\n        \n        gen_args.private_state.prev = nv;\n        return nv;\n    };\n}};\n\n_functions.map = {fun: (args) => {\n    const {f: func} = expand_args({f: (x) => x}, args);\n\n    return (value, gen_args, run_args) => func(value, gen_args, ...run_args);\n}};\n\n_functions.clip = {doc: {\n    title: \"Clip a value between two thresholds\"\n    , command: [\n        \"clip(u, l, s)\", \"clip({u, l, s})\"\n    ]\n    , params: {\n        u: \"Upper bound. Default is 1\"\n        , l: \"Lower bound. Default is 0\"\n        , s: \"Scale to apply to inpcoming value *before* clipping. Default is 1\"\n        , o: \"Offset to add *after* clipping. Default is 0\"\n    }\n    , return: \"A value in the range of `[l, u] + o`.\"\n    , description: `Allows you to ensure the values are within an aceptable\nrange for the following operations.`\n    , examples: [`shape(3).rotate(\n    L.set(L.time(), 'init')\n        .use('init')\n        .map((x, {time}) => time - x)\n        .clip(10)\n        .map((x) => (10 - x)/10)\n        .rad()\n).out(o0);`\n    ]\n}\n, fun: (args) => {\n    const {u: upper, l: lower, s: scale, o: offset} = expand_args({u: 1, l: 0, s: 1, o: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [uv, lv, sv, ov] = freeze_values([upper, lower, scale, offset], run_args, gen_args);\n\n        const v = undefault(input, 0) * sv;\n        \n        return (v > uv ? uv : (v < lv ? lv : v)) + ov;\n    };\n}};\n\nexport const functions = {\n    __category: \"modifiers\"\n    , __doc: {\n        title: \"Modifier functions\"\n        , description: `Functions that modify Hydra LFO values in some way or\nanother.`\n    }\n    , ..._functions\n};\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, undefault, expand_args, freeze_values, mix_values, get_time, get_bpm} from \"./util\";\n\nconst _functions = {};\n\n_functions.speed = {fun: (args) => {\n    const {v: value, m: mix} = expand_args({v: ud, m: ud}, args);\n\n    return (input, gen_args, run_args) => {\n        const [vv, mv] = freeze_values([value, mix], run_args, gen_args);\n        \n        let time_scale = 1;\n        if (typeof vv === 'undefined') {\n            if (typeof input !== 'undefined') {\n                time_scale = input;\n            }\n        } else if (typeof input === 'undefined') {\n            time_scale = vv;\n        } else if (typeof mv === 'undefined') {\n            time_scale = vv;\n        } else {\n            time_scale = mix_values(vv, input, mv);\n        }\n\n        gen_args.values.time = time_scale * gen_args.values.time;\n\n        return input;\n    };\n}};\n\n_functions.fast = {fun: (args) => {\n    const {s: scale, o: offset, m: mix} = expand_args({s: ud, o: 0, m: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [sv, ov, mv] = freeze_values([scale, offset, mix], run_args, gen_args);\n        \n        let time_scale = 1;\n        if (typeof input === 'undefined') {\n            if (typeof sv !== 'undefined') {\n                time_scale = sv;\n            }\n        } else if (typeof sv === 'undefined') {\n            time_scale = input;\n        } else {\n            time_scale = mix_values(sv, input, mv);\n        }\n\n        gen_args.values.time = (time_scale * gen_args.values.time) + ov;\n        \n        return input;\n    };\n}};\n\n_functions.slow = {fun: (args) => {\n    const {s: scale, o: offset, m: mix} = expand_args({s: ud, o: 0, m: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [sv, ov, mv] = freeze_values([scale, offset, mix], run_args, gen_args);\n        \n        let time_scale = 1;\n        if (typeof input === 'undefined') {\n            if (typeof sv !== 'undefined') {\n                time_scale = sv;\n            }\n        } else if (typeof sv === 'undefined') {\n            time_scale = input;\n        } else {\n            time_scale = mix_values(sv, input, mv);\n        }\n        if (time_scale === 0) {\n            time_scale = 1;\n        }\n\n        gen_args.values.time = (gen_args.values.time / time_scale) + ov;\n        \n        return input;\n    };\n}};\n\n_functions.time = {fun: (args) => {\n    const {s: scale, o: offset} = expand_args({s: 1, o: 0}, args);\n\n    return (input, gen_args, run_args) => {\n        const [sv, ov] = freeze_values([scale, offset], run_args, gen_args);\n\n        return (get_time(gen_args, run_args) * sv) + ov;\n    };\n}};\n\nexport const functions = {\n    __category: \"time\"\n    , __doc: {\n        title: \"Time functions\"\n        , description: `Functions that affect the time such as slowing it down\nor speeding it up`\n    }\n    , ..._functions\n};\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nconst UUID = require(\"pure-uuid\");\n\n// eslint-disable-next-line no-empty-function\nexport const ud = ((function () {})());\n\nexport const CANARY = \"__hydralfo_func\";\n\nexport const mix_values = (a, b, m) => (m === 0 ? a : (m === 1 ? b : (a * (1 - m)) + (b * m)));\n\nexport const undefault = (x, def) => (typeof x === 'undefined' ? def : x);\n\nexport const expand_args = (arg_def, args) => {\n    const vals = {...undefault(arg_def, {})};\n\n    if (typeof args !== 'undefined' && args.length > 0) {\n        const [first] = args;\n        if (typeof first === 'object' && !Array.isArray(first)) {\n            for (const x in arg_def) {\n                if (x in first) {\n                    vals[x] = first[x];\n                }\n            }\n        } else {\n            let defkeys = Object.keys(arg_def);\n            defkeys = defkeys.slice(0, Math.min(defkeys.length, args.length));\n            defkeys.forEach((k, i) => {\n                vals[k] = args[i];\n            });\n        }\n    }\n\n    Object.keys(vals).forEach((x) => {\n        const vx = vals[x];\n        const ax = arg_def[x];\n\n        if (typeof vx === 'function') {\n            vals[x] = (input, call_gen_args, call_args) => {\n                let nargs = call_args;\n                if (typeof nargs === 'undefined') {\n                    nargs = [{}];\n                }\n                if (CANARY in vx) {\n                    // make a 1 level copy of the call args for the call to the sub-chain\n                    const new_call_args = [];\n\n                    nargs.forEach((arg) => {\n                        if (typeof arg === 'object') {\n                            if (Array.isArray(arg)) {\n                                new_call_args.push([...arg]);\n                            } else if (\"call\" in arg) {\n                                new_call_args.push(arg);\n                            } else {\n                                new_call_args.push({...arg});\n                            }\n                        } else {\n                            new_call_args.push(arg);\n                        }\n                    });\n\n                    return undefault(vx.run(new_call_args), ax);\n                }\n\n                return undefault(vx(input, call_gen_args, nargs), ax);\n            };\n        } else if (typeof vx === 'undefined') {\n            vals[x] = ax;\n        } else {\n            vals[x] = vx;\n        }\n    });\n\n    return vals;\n};\n\nexport const get_time = (gen_args, run_args, allow_undef = false) => {\n    let namedargs = run_args;\n\n    if (Array.isArray(namedargs) && namedargs.length > 0) {\n        [namedargs] = namedargs;\n    }\n\n    if (typeof namedargs === 'object' && !Array.isArray(namedargs)) {\n        const {time} = namedargs;\n        if (typeof time !== 'undefined') {\n            return time;\n        }\n    }\n\n    if (typeof gen_args !== 'undefined') {\n        if (typeof gen_args.values !== 'undefined' && typeof gen_args.values.time !== 'undefined') {\n            return gen_args.values.time;\n        }\n    }\n    if (typeof window !== 'undefined' && typeof window.time !== 'undefined') {\n        return window.time;\n    }\n    if (allow_undef) {\n        return ud;\n    }\n    return new Date().getTime() / 1000.0;\n};\n\nexport const get_bpm = (gen_args, run_args, allow_undef = false) => {\n    let namedargs = run_args;\n\n    if (Array.isArray(namedargs) && namedargs.length > 0) {\n        [namedargs] = namedargs;\n    }\n\n    if (typeof namedargs === 'object' && !Array.isArray(namedargs)) {\n        const {bpm} = namedargs;\n        if (typeof bpm !== 'undefined') {\n            return bpm;\n        }\n    }\n\n    if (typeof gen_args !== 'undefined'\n        && typeof gen_args.values !== 'undefined'\n        && gen_args.values.bpm !== 'undefined'\n    ) {\n        return gen_args.values.bpm;\n    }\n\n    if (allow_undef) {\n        return ud;\n    }\n    return 60;\n};\n\nexport const freeze_values = (v, args, gen_args) => {\n    if (typeof v === 'undefined') {\n        return v;\n    }\n    if (typeof v === 'function') {\n        return v(...args, gen_args);\n    }\n    if (Array.isArray(v)) {\n        return v.map((x) => freeze_values(x, args, gen_args));\n    }\n    return v;\n};\n\nexport const get_global_env = () => {\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    return global;\n};\n\nexport const uuid = () => new UUID(4).format();\n\nexport const cb_to_promise = (fn) => new Promise((res, rej) => {\n    const mycb = (...args) => {\n        res(args);\n    };\n    \n    try {\n        fn(mycb);\n    } catch (err) {\n        rej(err);\n    }\n});\n",
    "/* Copyright (C) 2019  oscons (github.com/oscons). All rights reserved.\n * Licensed under the GNU General Public License, Version 2.0.\n * See LICENSE file for more information */\n\nimport {ud, CANARY, get_time, get_bpm, undefault, get_global_env} from \"./components/util\";\n\nimport {functions as maths_functions} from './components/maths';\nimport {functions as generator_functions} from './components/generators';\nimport {functions as time_functions} from './components/time';\nimport {functions as general_functions} from './components/general';\nimport {functions as modifier_functions} from './components/modifiers';\nimport {functions as async_functions} from './components/async';\n\nconst DOCUMENTATION = {};\n\nconst BUILTIN_FUNCTIONS = [\n    maths_functions\n    , generator_functions\n    , time_functions\n    , general_functions\n    , modifier_functions\n    , async_functions\n].reduce((prev, ob) => {\n    let category = \"other\";\n    if ('__category' in ob) {\n        category = ob.__category;\n    }\n\n    if (!(category in DOCUMENTATION)) {\n        DOCUMENTATION[category] = {};\n    }\n    category = DOCUMENTATION[category];\n\n    if ('__doc' in ob) {\n        category.__doc = ob.__doc;\n    }\n\n    Object.entries(ob)\n        .filter(([name]) => name.indexOf(\"__\") !== 0)\n        .forEach(([name, value]) => {\n            const {fun, doc} = value;\n            category[name] = doc;\n            prev[name] = fun;\n        });\n    return prev;\n}, {});\n\nexport const get_doc = () => DOCUMENTATION;\n\nconst run_calls = (options, global_state, instance_state, calls, args) => {\n\n    const run_options = {...{return_undef: false}, ...options};\n\n    let run_args = args;\n    if (typeof run_args === 'undefined' || run_args.length === 0) {\n        run_args = [{}];\n    }\n    if (typeof run_args[0] === 'undefined') {\n        run_args[0] = {};\n    }\n\n    const gen_args = {\n        input: ud\n        , current_value: \"val\"\n        , values: {\n            val: ud\n            , initial_args: args\n            , ...run_args[0]\n        }\n        , global_state\n        , instance_state\n        , private_state: {}\n    };\n\n    gen_args.values.initial_time = get_time(gen_args.values, run_args);\n    gen_args.values.time = gen_args.values.initial_time;\n\n    gen_args.values.get_bpm = get_bpm(gen_args.values, gen_args.values);\n\n    run_args[0] = gen_args.values;\n\n    calls.forEach(([fncall, private_state]) => {\n        gen_args.private_state = private_state;\n        gen_args.input = gen_args.values[gen_args.current_value];\n\n        const res = fncall(gen_args.input, gen_args, run_args);\n\n        gen_args.values[gen_args.current_value] = res;\n    });\n    \n    const rval = gen_args.values[gen_args.current_value];\n    if (typeof rval === 'undefined' && !run_options.return_undef) {\n        return undefault(gen_args.values.time, 0);\n    }\n\n    return rval;\n};\n\nconst sub_call = (global_state, prev_calls, fun) => {\n    const calls = prev_calls.map((x) => [x, {}]);\n    const instance_state = {};\n\n    if (typeof fun !== 'undefined') {\n        calls.push([fun, {}]);\n    }\n\n    const option_call = (options, args) => run_calls(options, global_state, instance_state, calls, args);\n\n    const run_function = (...args) => option_call({}, args);\n    run_function.run = run_function;\n    run_function.gen = (options) => (...args) => option_call(options, args);\n    run_function[CANARY] = true;\n\n    Object.entries(BUILTIN_FUNCTIONS).forEach(([name, gen]) => {\n        if (name in run_function && !(name in Object.getOwnPropertyNames())) {\n            throw new Error(`${name} already exists on parents of run_function`);\n        }\n\n        run_function[name] = (...args) => sub_call(\n            global_state\n            , calls.map(([call]) => call)\n            , gen(args)\n        );\n    });\n\n    return run_function;\n};\n\nconst make_new_lfo = (state) => {\n    const fdef = {};\n    const global_state = undefault(state, {});\n    \n    global_state.cleanup = [];\n\n    const functions = BUILTIN_FUNCTIONS;\n\n    Object.keys(functions).forEach((name) => {\n        fdef[name] = (...args) => sub_call(global_state, [])[name](...args);\n    });\n\n    fdef.__release = (new_lfo) => {\n        global_state.cleanup.forEach((cfn) => {\n            cfn(global_state, new_lfo);\n        });\n    };\n\n    return fdef;\n};\n\nconst GLOBAL_INIT_ID = \"__hydralfo_global\";\n\nexport const init = (args) => {\n    const {state = ud, init_global = true, force = false} = undefault(args, {});\n    const new_lfo = make_new_lfo(state);\n\n    if (!init_global) {\n        return new_lfo;\n    }\n\n    const env = get_global_env();\n\n    if (typeof env !== 'undefined') {\n        if (GLOBAL_INIT_ID in env) {\n            const old_lfo = env[GLOBAL_INIT_ID];\n            if (typeof old_lfo === 'object') {\n                if ('__release' in old_lfo) {\n                    old_lfo.__release(new_lfo);\n                }\n                if (!force) {\n                    return old_lfo;\n                }\n            }\n        }\n        env[GLOBAL_INIT_ID] = new_lfo;\n    }\n\n    return new_lfo;\n};\n"
  ]
}